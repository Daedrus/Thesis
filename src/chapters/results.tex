\chapter{Results}
\label{chapter:results}

\section{Test infrastructure description}
\label{section:testprogram}

In order to create a test program for the above methods we have to determine the requirements for such a program. Since we are interested in determining allocation sizes and allocation points, the test program has to provide a sufficiently diverse combination of these. Our program also has to be deterministic so that we test the methods against the same sequence of allocations. The number of allocations has to be sufficiently high so that the overhead of monitoring becomes noticeable.

In order to keep things simple and focus on the techniques and not on what the program does, the main task of our test program is to allocate a linked list whose nodes contain pointers to malloc-allocated memory whose size is controllable. In other words, we have a list of memory regions allocated with malloc. The linked list's nodes are also heap allocated and since there is one node for each allocation we can say that the number of actual allocations is twice that we give as input to the program. We are also interested in being able to control the depth at which the allocations are made, in order to be able to determine the overhead of stack tracing as the stack increases in size. Finally, the core loop of the test program has the following pseudocode, where capitalized variables are given by the user:

\begin{lstlisting}[label=pseudotest, caption=Test program core loop]
for NR_ITERATIONS do
	for size = START_SIZE, size < END_SIZE, size += STEP_SIZE
		call function such that allocation of size bytes is made at depth DEPTH in the call stack
\end{lstlisting}

First, we want to determine the overhead of determining the size of each allocation and compare it with the overhead of periodically sampling and traversing data structures. These are the two major approaches we can take in determining the amount of memory a specific program occupies. The final goal of allocation size monitoring is to be able to determine memory consumption on a per-module basis. Total memory consumption is not an issue, as this can be determined through other mechanisms which are usually provided by the operating system. The main problem is to have more fine grained memory reporting. For now, however, the test program is only interested in determining the total size of all the allocations we do. At this point, we are only trying to determine the overhead of obtaining the allocation data so we ignore the overhead of its utilization in finely grained memory reporting. In order to do this, we test the following scenarios:
\begin{enumerate}
\item \textit{On-demand data structure traversal} - go through the linked list and use malloc\_usable\_size on each node and the memory region it points to
\item \textit{On-demand counter based monitoring} - have the linked list hold a counter representing the total allocated size, which is updated whenever a node is added or removed; access the counter whenever the total allocated size is required
\item \textit{GCC provided malloc hooks} - use these to insert own code which updates a global variable containing total allocated bytes
\item \textit{GCC aided call replacement} - write own allocation routines which do the counting and then call the existing ones to actually do the allocation
\item \textit{Manually defined malloc-wrappers} - use the preprocessor or just write own routines which do the counting and then call the allocation routines
\item \textit{Dynamically linked library containing malloc implementations} - very similar to the call replacement except it is not GCC dependent
\end{enumerate}

Second, to determine the overhead of obtaining stack traces, we test the following:
\begin{enumerate}
\item \textit{GCC provided malloc hooks} - contain a parameter which gives the return address found on the stack
\item \textit{Global stack object} - manually keep a copy of the stack on the heap and access that copy whenever we want to a stack trace
\item \textit{Manual stack walk} - use low-level platform information about the stack's format to perform a manual walk
\item \textit{External library (libunwind)} - an existing library which abstracts away all the details of the stack and provides a simple way of accessing it
\end{enumerate}

